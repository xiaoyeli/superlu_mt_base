@extract -b Typedef.inc
/*
 * -- SuperLU MT routine (version 2.0) --
 * Lawrence Berkeley National Lab, Univ. of California Berkeley,
 * and Xerox Palo Alto Research Center.
 * September 10, 2007
 *
 * Sparse matrix types and function prototypes.
 *
 */

#ifndef __SUPERLU_@(pre)SP_DEFS /* allow multiple inclusions */
#define __SUPERLU_@(pre)SP_DEFS

/*
 * File name:           p@(pre)sp_defs.h
 * Purpose:             Sparse matrix types and function prototypes
 * History:
 */

/****************************
  Include thread header file
  ***************************/
#if defined ( _SOLARIS )
#include <thread.h>
#include <sched.h>
#elif defined( _DEC )
#include <pthread.h>
#include <unistd.h>
#include <sys/mman.h>
#elif defined ( _OPENMP )
#include <omp.h>
#elif defined ( _PTHREAD )
#include <pthread.h>
#elif defined ( _CRAY )
#include <fortran.h>
#include <string.h>
#endif

/* Define my integer type int_t */
typedef int int_t; /* default */

#include "slu_mt_machines.h"
#include "slu_mt_Cnames.h"
#include "supermatrix.h"
#include "slu_mt_util.h"
#include "pxgstrf_synch.h"

@precision DCOMPLEX SCOMPLEX
#include "slu_@(mod_pre)complex.h"
@precision !

/*
 * *************************************************
 *  Global data structures used in LU factorization
 * *************************************************
 * 
 *   nsuper: number of supernodes = nsuper+1, numbered between 0 and nsuper.
 *
 *   (supno, xsup, xsup_end):
 *      supno[i] is the supernode number to which column i belongs;
 *	xsup[s] points to the first column of supernode s;
 *      xsup_end[s] points to one past the last column of supernode s.
 *	Example: supno  0 1 2 2 3 3 3 4 4 4 4 4   (n=12)
 *	          xsup  0 1 2 4 7
 *            xsup_end  1 2 4 7 12
 *	Note: dfs will be performed on supernode rep. relative to the new 
 *	      row pivoting ordering
 *
 *   (lsub, xlsub, xlsub_end):
 *      lsub[*] contains the compressed subscripts of the supernodes;
 *      xlsub[j] points to the starting location of the j-th column in
 *               lsub[*]; 
 *      xlsub_end[j] points to one past the ending location of the j-th
 *               column in lsub[*].
 *	Storage: original row subscripts in A.
 *
 *      During the course of sparse LU factorization, we also use
 *	(lsub, xlsub, xlsub_end, xprune) to represent symmetrically 
 *      pruned graph. Contention will occur when one processor is
 *      performing DFS on supernode S, while another processor is pruning
 *      supernode S. We use the following data structure to deal with
 *      this problem. Suppose each supernode contains columns {s,s+1,...,t},
 *      with first column s and last column t.
 *
 *      (1) if t > s, only the subscript sets for column s and column t
 *          are stored. Column t represents pruned adjacency structure.
 *
 *                  --------------------------------------------
 *          lsub[*]    ... |   col s    |   col t   | ...
 *                  --------------------------------------------
 *                          ^            ^           ^
 *                       xlsub[s]    xlsub_end[s]  xlsub_end[s+1]
 *                                   xlsub[s+1]      :
 *                                       :           :
 *                                       :         xlsub_end[t]
 *                                   xlsub[t]      xprune[t] 
 *                                   xprune[s]    
 *
 *      (2) if t == s, i.e., a singleton supernode, the subscript set
 *          is stored twice:
 *
 *                  --------------------------------------
 *          lsub[*]    ... |      s     |     s     | ...
 *                  --------------------------------------
 *                          ^            ^           ^
 *                       xlsub[s]   xlsub_end[s]  xprune[s]
 *
 *      There are two subscript sets for each supernode, the last column
 *      structures (for pruning) will be removed after the numerical LU
 *      factorization phase:
 *        o lsub[j], j = xlsub[s], ..., xlsub_end[s]-1
 *          is the structure of column s (i.e. structure of this supernode).
 *          It is used for the storage of numerical values.
 *	  o lsub[j], j = xlsub[t], ..., xlsub_end[t]-1
 *	    is the structure of the last column t of this supernode.
 *	    It is for the purpose of symmetric pruning. Therefore, the
 *	    structural subscripts can be rearranged without making physical
 *	    interchanges among the numerical values.
 *
 *       DFS will traverse the first subscript set if the supernode
 *       has not been pruned; otherwise it will traverse the second
 *       subscript list, i.e., the part of the pruned graph.
 *
 *   (lusup, xlusup, xlusup_end):
 *      lusup[*] contains the numerical values of the supernodes;
 *      xlusup[j] points to the starting location of the j-th column in
 *                storage vector lusup[*]; 
 *      xlusup_end[j] points to one past the ending location of the j-th 
 *                column in lusup[*].
 *	Each supernode is stored in column-major, consistent with Fortran
 *      two-dimensional array storage.
 *
 *   (ucol, usub, xusub, xusub_end):
 *      ucol[*] stores the numerical values of the U-columns above the
 *              supernodes. 
 *      usub[k] stores the row subscripts of nonzeros ucol[k];
 *      xusub[j] points to the starting location of column j in ucol/usub[]; 
 *      xusub_end[j] points to one past the ending location column j in
 *                   ucol/usub[].
 *	Storage: new row subscripts; that is indexed intp PA.
 *
 */
typedef struct {
    int     *xsup;    /* supernode and column mapping */
    int     *xsup_end;
    int     *supno;   
    int     *lsub;    /* compressed L subscripts */
    int	    *xlsub;
    int     *xlsub_end;
    @(type)  *lusup;   /* L supernodes */
    int     *xlusup;
    int     *xlusup_end;
    @(type)  *ucol;    /* U columns */
    int     *usub;
    int	    *xusub;
    int     *xusub_end;
    int     nsuper;   /* current supernode number */
    int     nextl;    /* next position in lsub[] */
    int     nextu;    /* next position in usub[]/ucol[] */
    int     nextlu;   /* next position in lusup[] */
    int     nzlmax;   /* current max size of lsub[] */
    int     nzumax;   /*    "    "    "      ucol[] */
    int     nzlumax;  /*    "    "    "     lusup[] */
    /* ---------------------------------------------------------------
     *  Memory managemant for L supernodes 
     */
    int  *map_in_sup;  /* size n+1 - the address offset of each column
                        * in lusup[*], which is divided into regions 
			* by the supernodes of Householder matrix H.
			* If column k starts a supernode in H,
			* map_in_sup[k] is the next open position in
			* lusup[*]; otherwise map_in_sup[k] gives the
			* offset (negative) to the leading column
			* of the supernode in H.
			*/
    int  dynamic_snode_bound;
    /* --------------------------------------------------------------- */
} GlobalLU_t;


/* 
 * *********************************************************************
 * The pxgstrf_shared_t structure contains the shared task queue and
 * the synchronization variables to facilitate parallel factorization. 
 * It also contains the shared L and U data structures.
 * *********************************************************************
 */
typedef struct {
    /* ----------------------------------------------------------------
     * Global variables introduced in parallel code for synchronization.
     */
    volatile int tasks_remain; /* number of untaken panels */
    int          num_splits;   /* number of panels split at the top */
    queue_t      taskq;        /* size ncol - shared work queue */
    mutex_t      *lu_locks;    /* 5 named mutual exclusive locks */
    volatile int *spin_locks;  /* size ncol - mark every busy column */
    pan_status_t *pan_status;  /* size ncol - panel status */
    int          *fb_cols;     /* size ncol - mark farthest busy column */
    /* ---------------------------------------------------------------- */
    int        *inv_perm_c;
    int        *inv_perm_r;
    int        *xprune;
    int        *ispruned;
    SuperMatrix *A;
    GlobalLU_t *Glu;
    Gstat_t    *Gstat;
    int        *info;
} pxgstrf_shared_t;

/* Arguments passed to each thread. */
typedef struct {
    int  pnum; /* process number */
    int  info; /* error code returned from each thread */       
    superlumt_options_t *superlumt_options;
    pxgstrf_shared_t  *pxgstrf_shared; /* shared for LU factorization */
} p@(pre)gstrf_threadarg_t;


/* *********************
   Function prototypes
   *********************/

#ifdef __cplusplus
extern "C" {
#endif


/* ----------------
   Driver routines 
   ---------------*/
extern void
p@(pre)gssv(int, SuperMatrix *, int *, int *, SuperMatrix *, SuperMatrix *, 
       SuperMatrix *, int *);
extern void
p@(pre)gssvx(int, superlumt_options_t *, SuperMatrix *, int *, int *,  
	equed_t *, @(mod_type) *, @(mod_type) *, SuperMatrix *, SuperMatrix *,
	SuperMatrix *, SuperMatrix *, 
	@(mod_type) *, @(mod_type) *, @(mod_type) *, @(mod_type) *, superlu_memusage_t *, 
	int *);

/* ---------------
   Driver related 
   ---------------*/
extern void @(pre)gsequ (SuperMatrix *, @(mod_type) *, @(mod_type) *, @(mod_type) *,
                    @(mod_type) *, @(mod_type) *, int *);
extern void @(pre)laqgs (SuperMatrix *, @(mod_type) *, @(mod_type) *, @(mod_type), 
		    @(mod_type), @(mod_type), equed_t *);
extern void @(pre)gscon (char *, SuperMatrix *, SuperMatrix *,
		    @(mod_type), @(mod_type) *, int *);
extern @(mod_type) @(pre)PivotGrowth(int, SuperMatrix *, int *,
			   SuperMatrix *, SuperMatrix *);
extern void @(pre)gsrfs (trans_t, SuperMatrix *, SuperMatrix *, SuperMatrix *,
		    int *, int *, equed_t, @(mod_type) *, @(mod_type) *, SuperMatrix *,
		    SuperMatrix *, @(mod_type) *, @(mod_type) *, Gstat_t *, int *);
extern int  sp_@(pre)trsv (char *, char *, char *, SuperMatrix *, SuperMatrix *,
		      @(type) *, int *);
extern int  sp_@(pre)gemv (char *, @(type), SuperMatrix *, @(type) *,
		      int, @(type), @(type) *, int);
extern int  sp_@(pre)gemm (char *, int, int, int, @(type), SuperMatrix *, 
		      @(type) *, int, @(type), @(type) *, int);

/* ----------------------
   Factorization related
   ----------------------*/
extern void pxgstrf_scheduler (const int, const int, const int *,
			       int *, int *, pxgstrf_shared_t *);
extern int  @(pre)ParallelInit (int, pxgstrf_relax_t *, superlumt_options_t *,
			  pxgstrf_shared_t *);
extern int  ParallelFinalize ();
extern void p@(pre)gstrf_StackFree ();
extern int  queue_init (queue_t *, int);
extern int  queue_destroy (queue_t *);
extern int  EnqueueRelaxSnode (queue_t *, int, pxgstrf_relax_t *,
			      pxgstrf_shared_t *);
extern int  EnqueueDomains(queue_t *, struct Branch *, pxgstrf_shared_t *);
extern int  Enqueue (queue_t *, qitem_t);
extern int  Dequeue (queue_t *, qitem_t *);
extern int  NewNsuper (const int, pxgstrf_shared_t *, int *);
extern int  lockon(int *);
extern void PartDomains(const int, const float, SuperMatrix *, int *, int *);

extern void
@(pre)Create_CompCol_Matrix(SuperMatrix *, int, int, int, @(type) *,
		      int *, int *, Stype_t, Dtype_t, Mtype_t);
void
@(pre)Create_CompCol_Permuted(SuperMatrix *, int, int, int, @(type) *, int *,
			 int *, int *, Stype_t, Dtype_t, Mtype_t);
extern void
@(pre)Copy_CompCol_Matrix(SuperMatrix *, SuperMatrix *);
extern void
@(pre)Create_Dense_Matrix(SuperMatrix *, int, int, @(type) *, int,
		     Stype_t, Dtype_t, Mtype_t);
extern void
@(pre)Create_SuperNode_Matrix(SuperMatrix *, int, int, int, @(type) *, int *, int *,
			int *, int *, int *, Stype_t, Dtype_t, Mtype_t);
extern void
@(pre)Create_SuperNode_Permuted(SuperMatrix *, int, int, int, @(type) *, 
			   int *, int *, int *, int *, int *, int *, 
			   int *, int *, Stype_t, Dtype_t, Mtype_t);
extern void
@(pre)Copy_Dense_Matrix(int, int, @(type) *, int, @(type) *, int);

extern void Destroy_SuperMatrix_Store(SuperMatrix *);
extern void Destroy_CompCol_Matrix(SuperMatrix *);
extern void Destroy_CompCol_Permuted(SuperMatrix *);
extern void Destroy_CompCol_NCP(SuperMatrix *);
extern void Destroy_SuperNode_Matrix(SuperMatrix *);
extern void Destroy_SuperNode_SCP(SuperMatrix *);

extern void @(pre)allocateA (int, int, @(type) **, int **, int **);
extern void StatAlloc (const int, const int, const int, const int, Gstat_t*);
extern void StatInit  (const int, const int, Gstat_t*);
extern void StatFree  (Gstat_t*);
extern void get_perm_c(int, SuperMatrix *, int *);
extern void @(pre)sp_colorder (SuperMatrix *, int *, superlumt_options_t *,
			 SuperMatrix *);
extern int  sp_coletree (int *, int *, int *, int, int, int *);
extern int  @(pre)PresetMap (const int, SuperMatrix *, pxgstrf_relax_t *, 
		       superlumt_options_t *, GlobalLU_t *);
extern int  qrnzcnt (int, int, int *, int *, int *, int *, int *, int *,
		     int *, int *, int *, int *);
extern int  DynamicSetMap(const int, const int, const int, pxgstrf_shared_t*);
extern void p@(pre)gstrf (superlumt_options_t *, SuperMatrix *, int *, 
		     SuperMatrix *, SuperMatrix *, Gstat_t *, int *);
extern void p@(pre)gstrf_init (int, fact_t, trans_t, yes_no_t, int, int, @(mod_type), yes_no_t, double,
			  int *, int *, void *, int, SuperMatrix *,
			  SuperMatrix *, superlumt_options_t *, Gstat_t *);
extern p@(pre)gstrf_threadarg_t*
p@(pre)gstrf_thread_init (SuperMatrix *, SuperMatrix *, SuperMatrix *,
		     superlumt_options_t*, pxgstrf_shared_t*, Gstat_t*, int*);
extern void
p@(pre)gstrf_thread_finalize (p@(pre)gstrf_threadarg_t *, pxgstrf_shared_t *,
			 SuperMatrix *, int *, SuperMatrix *, SuperMatrix *);
extern void p@(pre)gstrf_finalize(superlumt_options_t *, SuperMatrix *);
extern void pxgstrf_finalize(superlumt_options_t *, SuperMatrix *);
extern void p@(pre)gstrf_relax_snode (const int, superlumt_options_t *,
				 pxgstrf_relax_t *);
extern int
p@(pre)gstrf_factor_snode (const int, const int, SuperMatrix *, const @(mod_type),
		      yes_no_t *, int *, int *, int*, int*, int*, int*,
		      @(type) *, @(type) *, pxgstrf_shared_t *, int *);
extern void
pxgstrf_mark_busy_descends (int, int, int *, pxgstrf_shared_t *, int *, int *);
extern int  p@(pre)gstrf_snode_dfs (const int, const int, const int, const int *,
			       const int *, const int *, int*, int *, int *,
			       pxgstrf_shared_t *);
extern int  p@(pre)gstrf_snode_bmod (const int, const int, const int, const int,
				@(type) *, @(type) *, GlobalLU_t*, Gstat_t*);
extern void p@(pre)gstrf_panel_dfs (const int, const int, const int, const int,
			       SuperMatrix *, int*, int*, int*, int*, int*, 
			       int*, int*, int*, int*, int*, int*, int*, int*,
			       @(type)*, GlobalLU_t *);
extern void p@(pre)gstrf_panel_bmod (const int, const int, const int, const int,
				const int, int*, int*, int*, int*, int*, int*,
				int*, int*, @(type)*, @(type)*, 
				pxgstrf_shared_t *);
extern void p@(pre)gstrf_bmod1D (const int, const int, const int, const int, 
			    const int, const int, const int, int, int,
			    int *, int *, int *, int *, @(type) *, @(type) *, 
			    GlobalLU_t *, Gstat_t *);
extern void p@(pre)gstrf_bmod2D (const int, const int, const int, const int,
			    const int, const int, const int, int, int,
			    int *, int *, int *, int *, @(type) *, @(type) *,
			    GlobalLU_t *, Gstat_t *);
extern void p@(pre)gstrf_bmod1D_mv2 (const int, const int, const int, const int, 
				const int, const int, const int, int, int,
				int *, int *, int *, int *, @(type) *, 
				@(type) *, GlobalLU_t *, Gstat_t *);
extern void p@(pre)gstrf_bmod2D_mv2 (const int, const int, const int, const int,
				const int, const int, const int, int, int,
				int *, int *, int *, int *, @(type) *, @(type) *,
				GlobalLU_t *, Gstat_t *);
extern void pxgstrf_super_bnd_dfs (const int, const int, const int, 
				   const int, const int, SuperMatrix*,
				   int*, int*, int*, int *, int *, int *,
				   int *, pxgstrf_shared_t *);
extern int  p@(pre)gstrf_column_dfs(const int, const int, const int, const int,
			       int*, int*, int*, int, int*, int*, int*, int*,
			       int *, int *, int *, int *, pxgstrf_shared_t *);
extern int  p@(pre)gstrf_column_bmod(const int, const int, const int, const int, 
				int*, int*, @(type)*, @(type)*,
				pxgstrf_shared_t *, Gstat_t *);
extern int  p@(pre)gstrf_pivotL (const int, const int, const @(mod_type), yes_no_t*,
			    int*, int*, int*, int*, GlobalLU_t*, Gstat_t*);
extern int  p@(pre)gstrf_copy_to_ucol (const int, const int, const int, const int *,
				  const int *, const int *, @(type)*,
				  pxgstrf_shared_t*);
extern void pxgstrf_pruneL (const int, const int *, const int, const int,
			    const int *, const int *, int*, int *,
			    GlobalLU_t *);
extern void pxgstrf_resetrep_col (const int, const int *, int *);
extern void countnz (const int, int*, int *, int *, GlobalLU_t *);
extern void fixupL (const int, const int *, GlobalLU_t *);
extern void compressSUP (const int, GlobalLU_t *);
extern int  spcoletree (int *, int *, int *, int, int, int *);
extern int  *TreePostorder (int, int *);
extern void @(pre)readmt (int *, int *, int *, @(type) **, int **, int **);
extern void @(pre)readhb (int *, int *, int *, @(type) **, int **, int **);
extern void @(pre)GenXtrue (int, int, @(type) *, int);
extern void @(pre)FillRHS (trans_t, int, @(type) *, int, 
		      SuperMatrix *, SuperMatrix *);
extern void @(pre)gstrs (trans_t, SuperMatrix *, SuperMatrix*, 
		    int*, int*, SuperMatrix*, Gstat_t *, int *);
extern void @(pre)lsolve (int, int, @(type) *, @(type) *);
extern void @(pre)usolve (int, int, @(type) *, @(type) *);
extern void @(pre)matvec (int, int, int, @(type) *, @(type) *, @(type) *);


/* ---------------
   BLAS 
   ---------------*/
extern int @(pre)gemm_(char*, char*, int*, int*, int*, @(type)*,
                  @(type)*, int*, @(type)*, int*, @(type)*,
                  @(type)*, int*);
extern int @(pre)trsm_(char*, char*, char*, char*, int*, int*, @(type)*,
                  @(type)*, int*, @(type)*, int*);
extern int @(pre)trsv_(char*, char*, char*, int*, @(type)*, int*,
                  @(type)*, int*);
extern int @(pre)gemv_(char*, int*, int*, @(type)*, @(type)*, 
		   int*, @(type)*, int*, @(type)*, @(type)*, int*);

/* ---------------
   Memory related 
   ---------------*/
extern float p@(pre)gstrf_MemInit (int, int, superlumt_options_t *,
			SuperMatrix *, SuperMatrix *, GlobalLU_t *);
extern float p@(pre)gstrf_memory_use(const int, const int, const int);
extern int  p@(pre)gstrf_WorkInit (int, int, int **, @(type) **);
extern void pxgstrf_SetIWork (int, int, int *, int **, int **, int **,
		      int **, int **, int **, int **);
extern void p@(pre)gstrf_SetRWork (int, int, @(type) *, @(type) **, @(type) **);
extern void p@(pre)gstrf_WorkFree (int *, @(type) *, GlobalLU_t *);
extern int  p@(pre)gstrf_MemXpand (int, int, MemType, int *, GlobalLU_t *);

extern int  *intMalloc (int);
extern int  *intCalloc (int);
extern @(type) *@(type)Malloc(int);
extern @(type) *@(type)Calloc(int);
extern int  memory_usage ();
extern int  superlu_@(pre)QuerySpace (int, SuperMatrix *, SuperMatrix *, int, 
				 superlu_memusage_t *);
extern int  Glu_alloc (const int, const int, const int, const MemType,
		       int *, pxgstrf_shared_t *);

/* -------------------
   Auxiliary routines
   -------------------*/
extern double  SuperLU_timer_();
extern int     sp_ienv(int);
extern double  @(mod_pre)lamch_();
extern int     lsame_(char *, char *);
extern int     xerbla_(char *, int *);
extern void    superlu_abort_and_exit(char *);
extern void    ifill(int *, int, int);
extern void    @(pre)fill(@(type) *, int, @(type));
extern void    @(pre)inf_norm_error(int, SuperMatrix *, @(type) *);
extern void    dstat_allocate(int);
extern void    snode_profile(int, int *);
extern void    super_stats(int, int *, int *);
extern void    panel_stats(int, int, int *, Gstat_t *);
extern void    PrintSumm(char *, int, int, int);
extern void    @(pre)PrintPerf(SuperMatrix *, SuperMatrix *, superlu_memusage_t *,
			 @(mod_type), @(mod_type), @(mod_type) *, @(mod_type) *, char *,
			 Gstat_t *);
extern void    @(pre)CompRow_to_CompCol(int m, int n, int nnz, 
                           @(type) *a, int *colind, int *rowptr,
                           @(type) **at, int **rowind, int **colptr);


/* -----------------------
   Routines for debugging
   -----------------------*/
extern void    print_lu_col(int, char *, int, int, int, int *, GlobalLU_t *);
extern void    print_panel_seg(int, int, int, int, int *, int *);
extern void    @(pre)check_zero_vec(int, char *, int, @(type) *);
extern void    check_repfnz(int, int, int, int *);

#ifdef __cplusplus
	   }
#endif


#endif /* __SUPERLU_@(PRE)SP_DEFS */

